1 - Tentez d'expliquer pourquoi certains langages sont plus rapides que d'autres dans cette expérience.

Afin de fournir une explication détaillée il est impératif de prendre en compte l'environnement depuis lequel nos programmes sont éxécutés. Ainsi, nous travaillons depuis une Debian, une distribution Linux (construit à partir d'un noyau Unix). On remarque sur le fichier "dynamic_array_amortized_time_alpha_2.pdf" une différence de performance /*Analyse temps amorti*/ entre les différents langages, avec un fort avantage pour le langage C et C++. En effet, ce sont tous deux des langages dit de "bas niveau", c'est à dire qu'ils manipulent des registres, adresses mémoires et des instructions machines. De plus, il est important de préciser que le noyau Unix est en grande partie écrit en langage C, ce qui explique les performances du C face au C++. Dans le cas des langages Java et Python, langage dit de "haut niveau", ils sont moins performants notament parce qu'ils font abstraction des concepts de registres, de zones mémoires et de piles.

2 - Observez l'espace mémoire inutilisé au fur et à mesure du programme. Qu'en pensez vous? Imaginez un scénario dans lequel cela pourrait poser problème.

Au fur et à mesure que l'on ajoute des éléments dans nos tables dynamiques ont remarques d'importants pics de croissances d'espace mémoires inutilisé, et de manière plus fréquente pour le langage Python. Là où la quantité d'espace mémoire inutilisée diminue de manière progresive pour le C (car apres avoir doublé la taille de la table dynamique on ne fait qu'ajouter tant que la table n'est pas pleine), celle-ci diminue de manière drastique  pour le langage python. Le pire des scénarios serait le cas dans lequel on ajoute un élément dans une table dynamique pleine et que notre programme s'arrete apres l'ajout de cet element. En effet, le programme aura alloué de l'espace supplémentaire pour notre table dynamique uniquement pour un element, ce qui évidement n'est pas optimal.

3 - Décrivez les différences obtenues en faisant varier alpha dans les deux expériences.

La valeur d'alpha qui m'a été attribuée est 1.5, n'etant pas tres différente de celle de départ à savoir 2 on ne remarque pas de grandes différences pour l'analyse du coût amorti et le nombre de copies effectués (présence de différences mais très minime). Toutefois, en ce qui concerne l'analyse de l'espace mémoire gaspillée, on remarque une différence dû au fait qu'avec notre valeur d'alpha (1.5) l'espace mémoire réalloué est inférieur a celui avec la valeur d'alpha de départ. Ainsi, on arrive plus souvent a saturation dans notre table dynamique et donc on réalloue plus fréquemment de l'espace mémoire.
